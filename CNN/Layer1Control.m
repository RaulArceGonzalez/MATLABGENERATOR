% This function generates the module for the control signal generator of
% the first layer of the CNN part of the network
% INPUTS
% Number of bits of the input data of the layer
% Number of data to be processed by the convolutional filters
function [] = Layer1Control(input_size, mult1)
        name = sprintf('CNN_Network/CNN/GEN1.vhd');
        fid = fopen(name, 'wt');
        fprintf(fid, '----------------------------GENERATOR LAYER 1----------------------------\n');
        fprintf(fid, '--This module is in charge of producing all the control signals of its layer, which allow to synchronize the operation of all the modules.\n');
        fprintf(fid, '--INPUTS\n');
        fprintf(fid, '--dato_in : indicates that there is a data to be processed in the layer\n');
        fprintf(fid, '--data_zero1 : indicates that the data to be processed by the first set of neurons is a zero from the padding zone.\n');
        fprintf(fid, '--data_zero2 : indicates that the data to be processed by the second set of neurons is a zero from the padding zone.\n');
        fprintf(fid, '\n');
        fprintf(fid, '--OUTPUTS\n');
        fprintf(fid, '--mul : indicates the multiplication of the filter we are performing at the moment\n');
        fprintf(fid, '--count : counter from 0 to 2^(signal length) + 2 that we pass to the serial parallel converter to encode the signal.\n');
        fprintf(fid, '--en_neuron : inidcates when the neuron is processing a valid input\n');
        fprintf(fid, '--data_out1 : signal that notifies that the processing of a data in this layer is finished.\n');
        fprintf(fid, '--data_out2 : signal notifying that a data is available for processing in the next layer\n');
        fprintf(fid, '--next_pipeline_step: indicates that the processing of a data in the convolution has been completed\n');
        fprintf(fid, '\n');
        fprintf(fid, 'library IEEE;\n');
        fprintf(fid, 'use IEEE.STD_LOGIC_1164.ALL;\n');
        fprintf(fid, 'use work.tfg_irene_package.ALL;\n');
        fprintf(fid, 'use IEEE.NUMERIC_STD.ALL;\n');
        fprintf(fid, 'entity GEN1 is\n');
        fprintf(fid, 'Port (clk : in std_logic;\n');
        fprintf(fid, '      rst : in std_logic;\n');
        fprintf(fid, '      rst_red : in std_logic;\n');
        fprintf(fid, '      data_in : in std_logic;\n');
        fprintf(fid, '      data_zero1 : in std_logic;\n');
        fprintf(fid, '      data_zero2 : in std_logic;\n');
        fprintf(fid, '      count : out unsigned( log2c(input_sizeL1)-1   downto 0);\n');
        fprintf(fid, '      mul: out std_logic_vector(log2c(mult1) - 1 downto 0);\n');
        fprintf(fid, '      en_neuron : out std_logic;\n');
        fprintf(fid, '      data_out1: out std_logic;\n');
        fprintf(fid, '      data_out2 : out std_logic;\n');
        fprintf(fid, '      next_pipeline_step : out std_logic);\n');
        fprintf(fid, 'end GEN1;\n');
        fprintf(fid, 'architecture Behavioral of GEN1 is\n');
        fprintf(fid, 'type state_type is (idle , s_wait, s0, s1, s2);\n');
        fprintf(fid, '--REGISTERS\n');
        fprintf(fid, 'signal state_reg, state_next : state_type;\n');
        fprintf(fid, 'signal count_reg, count_next: unsigned(log2c(input_sizeL1)-1 + log2c(mult1) + log2c(pool2_size) downto 0) :=  (others=>''0'');\n');
        fprintf(fid, 'signal next_pipeline_step_reg, next_pipeline_step_next, data2_reg, data2_next, data_reg , data_next: std_logic;\n');
        fprintf(fid, '--CONSTANTS\n');
        fprintf(fid, 'signal data_max : unsigned(log2c(input_sizeL1) - 1 downto 0):=  (others=>''0'');\n');
        fprintf(fid, 'Begin \n');
        fprintf(fid, '--Register\n');
        fprintf(fid, 'process(clk)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '    if (clk''event and clk = ''1'') then\n');
        fprintf(fid, '        if (rst = ''0'') then\n');
        fprintf(fid, '            count_reg <= (others => ''0'');\n');
        fprintf(fid, '            state_reg <= idle;\n');
        fprintf(fid, '            data_reg <= ''0'';\n');
        fprintf(fid, '            data2_reg <= ''0'';\n');
        fprintf(fid, '            next_pipeline_step_reg <= ''0'';\n');
        fprintf(fid, '        else\n');
        fprintf(fid, '            state_reg <= state_next;\n');
        fprintf(fid, '            next_pipeline_step_reg <= next_pipeline_step_next;\n');
        fprintf(fid, '            data_reg <= data_next;\n');
        fprintf(fid, '            data2_reg <= data2_next;\n');
        fprintf(fid, '            count_reg <= count_next;\n');
        fprintf(fid, '        end if;\n');
        fprintf(fid, '    end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, ' --Next-state logic \n');
        fprintf(fid, 'process(rst_red, data_zero1, data_zero2, state_reg, data_reg, data_max, data_in, count_reg, next_pipeline_step_reg, data2_reg)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '    count_next <= count_reg;\n');
        fprintf(fid, '    state_next <= state_reg;\n');
        fprintf(fid, '    next_pipeline_step_next <= next_pipeline_step_reg;\n');
        fprintf(fid, '    data_next <= data_reg;\n');
        fprintf(fid, '    data2_next <= data2_reg;\n');
        fprintf(fid, '    en_neuron <= ''0'';\n');
        fprintf(fid, 'case state_reg is \n');
        fprintf(fid, 'when idle  =>           --Reset state\n');
        fprintf(fid, '     data_next <= ''0'';\n');
        fprintf(fid, '     data2_next <= ''0'';\n');
        fprintf(fid, '     next_pipeline_step_next <=''0'';\n');
        fprintf(fid, '     count_next <= (others=>''0'');\n');
        fprintf(fid, '     state_next <= s_wait;\n');
        fprintf(fid, 'when s_wait =>                  --Wait for a new data to be processed\n');
        fprintf(fid, '     next_pipeline_step_next <=''0'';\n');
        fprintf(fid, '     data_next <= ''0'';\n');
        fprintf(fid, '     data2_next <= ''0'';\n');
        fprintf(fid, '     if(data_in = ''1'') then    --When new data is availale to be processed if both of them are zero we don''t have to do the MAAC operation as the result will be direclty zero if one of them is not zero we move to the processing state.\n');
        fprintf(fid, '       if(data_zero1 = ''1'' and data_zero2 = ''1'') then\n');
        fprintf(fid, '          state_next <= s2;\n');
        fprintf(fid, '        else\n');
        fprintf(fid, '           state_next <= s0;\n');
        fprintf(fid, '        end if;\n');
        fprintf(fid, '     end if;  \n');
        fprintf(fid, '     if(rst_red = ''1'') then\n');
        fprintf(fid, '          state_next <= idle;\n');
        fprintf(fid, '     end if; \n');       
        fprintf(fid, "when s0 =>\n");
        fprintf(fid, "        state_next <= s1;\n");
        fprintf(fid, "when s1 =>\n");
        fprintf(fid, "next_pipeline_step_next <= '0';\n");
        fprintf(fid, "data_next <= '0';\n");
        fprintf(fid, "en_neuron <= '1';\n");
        fprintf(fid, "if(count_reg(log2c(input_sizeL1)-1 downto 0) = count1_max ) then\n");
        fprintf(fid, "      if((count_reg(log2c(mult1) + log2c(input_sizeL1)-1 downto log2c(input_sizeL1)) = mult1 - 1)) then\n");
        fprintf(fid, "        data_next <= '0';\n");
        fprintf(fid, "      else\n");
        fprintf(fid, "        data_next <= '1';\n");
        fprintf(fid, "      end if;\n");
        fprintf(fid, "      count_next <= count_reg + 1;\n");
        fprintf(fid, "elsif(count_reg(log2c(input_sizeL1)-1 downto 0) = data_max) then\n");
        fprintf(fid, "    if(count_reg(log2c(mult1) + log2c(input_sizeL1)-1 downto log2c(input_sizeL1)  )= mult1 - 1) then\n");
        fprintf(fid, "      if(count_reg(log2c(input_sizeL1)-1 + log2c(mult1) + log2c(pool2_size) downto log2c(mult1) + log2c(input_sizeL1)) = pool2_size - 1) then\n");
        fprintf(fid, "          data2_next <= '1';\n");
        fprintf(fid, "      else\n");
        fprintf(fid, "         next_pipeline_step_next <= '1';\n");
        fprintf(fid, "      end if;\n");
        a = strcat(num2str(dec2bin(mult1 - 1)), num2str(dec2bin(input_size - 1)));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, "          count_next <= count_reg + %d;\n", n);
        fprintf(fid, "    else\n");
        a = strcat(num2str(dec2bin(input_size - 1)));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, "          count_next <= count_reg + %d;\n", n);
        fprintf(fid, "   end if;\n");
        fprintf(fid, "             state_next <= s_wait;\n");
        fprintf(fid, "else\n");
        fprintf(fid, "    count_next <= count_reg + 1;\n");
        fprintf(fid, "end if;\n");
        fprintf(fid, "\n");
        fprintf(fid, "when s2 =>\n");
        fprintf(fid, "next_pipeline_step_next <= '0';\n");
        fprintf(fid, "data_next <= '0';\n");
        fprintf(fid, "data2_next <= '0';\n");
        fprintf(fid, "    if(count_reg(log2c(mult1) + log2c(input_sizeL1)-1 downto log2c(input_sizeL1)  )= mult1 - 1) then\n");
        fprintf(fid, "      if(count_reg(log2c(input_sizeL1)-1 + log2c(mult1) + log2c(pool2_size) downto log2c(mult1) + log2c(input_sizeL1)) = pool2_size - 1) then\n");
        fprintf(fid, "          data2_next <= '1';\n");
        fprintf(fid, "      else\n");
        fprintf(fid, "         next_pipeline_step_next <= '1';\n");      
        fprintf(fid, '      end if;\n');
        a = strcat(num2str(dec2bin(mult1 - 1)), num2str(dec2bin(0, log2(input_size))));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '          count_next <= count_reg + %d;\n', n);
        fprintf(fid, '    else\n');
        fprintf(fid, '      data_next <= ''1'';\n');
        a = strcat(num2str(dec2bin(0, log2(input_size))));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '      count_next <= count_reg + %d;   --As the data input is zero we don''t need to process it so we move directly to the next data\n', n);
        fprintf(fid, '   end if;\n');
        fprintf(fid, '         state_next <= s_wait;\n');
        fprintf(fid, 'end case;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, "--Constants\n");
        fprintf(fid, "data_max <= (others => '1');\n");
        fprintf(fid, "\n--Output logic\n");
        fprintf(fid, "data_out1 <= data_reg;\n");
        fprintf(fid, "data_out2 <= data2_reg;\n");
        fprintf(fid, "count <= count_reg(log2c(input_sizeL1)-1 downto 0);\n");
        fprintf(fid, "mul <= std_logic_vector(count_reg(log2c(mult1) + log2c(input_sizeL1)-1 downto log2c(input_sizeL1)));\n");
        fprintf(fid, "next_pipeline_step <= next_pipeline_step_reg;\n");
        fprintf(fid,'end Behavioral;\n');
        fclose(fid);          
end


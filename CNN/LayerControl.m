% This function generates the module for the control signal generator of each layer of the CNN part of the network
% INPUTS
% Number of layer of the generator
% Number of data to be processed by the convolutional filters
% Number of bits of the input data of the layer
% Number of layers of the convolutional filters (z dimension)
function [] = LayerControl(layer, mult, input_size, conv_z)
        name = sprintf('CNN_Network/CNN/GEN%d.vhd', layer);
        fid = fopen(name, 'wt');
        fprintf(fid,'----------------------------GENERATOR LAYER %d----------------------------\n', layer);
        fprintf(fid,'--This module is in charge of producing all the control signals of its layer, which allow to synchronize the operation of all the modules.\n');
        fprintf(fid,'--INPUTS\n');
        fprintf(fid,'--data_in : indicates that there is a data to be processed in the layer.\n');
        fprintf(fid,'--data_zero : indicates if the data to be processed corresponds to a zero from the padding layer of the input image\n');
        fprintf(fid,'--OUTPUTS\n');
        fprintf(fid,'--layer : indicates the layer of the matrix resulting from the previous stage that we are processing at this moment.\n');
        fprintf(fid,'--mul : indicates the multiplication of the filter that we are performing at that moment.\n');
        fprintf(fid,'--count : counter from 0 to 2^(signal length) + 2 that we pass to the serial parallel converter to encode the signal.\n');
        fprintf(fid,'--data_out1 : signal notifying that the processing of a data in this layer is finished\n');
        fprintf(fid,'--data_out2 : signal notifying that a data is available to process in the next layer\n');
        fprintf(fid,'--index: signal that is passed to the relu module to transmit the stored data.\n');
        fprintf(fid,'--en_neuron: signal that is kept at 1 when the neuron is receiving data, it is passed to a multiplexer at the output of the par2ser converter because it would send a pulse out of time. \n');
        fprintf(fid,'--next_dato_pool: indicates that there is new data to process from the pool module. \n');
        fprintf(fid,'--next_pipeline_step: indicates that it has finished processing a data in the convolution.\n');
        fprintf(fid,'\n');
        fprintf(fid, 'library IEEE;\n');
        fprintf(fid, 'use IEEE.STD_LOGIC_1164.ALL;\n');
        fprintf(fid, 'use work.tfg_irene_package.ALL;\n');
        fprintf(fid, 'use IEEE.NUMERIC_STD.ALL;\n');
        fprintf(fid, 'entity GEN%d is\n', layer);
        fprintf(fid,' Port ( clk : in STD_LOGIC;\n');
        fprintf(fid,'        rst : in STD_LOGIC;\n');
        fprintf(fid,'        rst_red : in std_logic;\n');
        fprintf(fid,'        data_in : in std_logic;\n');
        fprintf(fid,'        data_zero : in std_logic;\n');
        fprintf(fid,'        count : out unsigned( log2c(input_sizeL%d)-1 downto 0);\n', layer);
        fprintf(fid,'        layer : out STD_LOGIC_VECTOR(log2c(number_of_layers%d) - 1 downto 0);\n', layer);
        fprintf(fid,'        mul: out std_logic_vector(log2c(mult%d) - 1 downto 0);\n', layer);
        fprintf(fid,'        data_out1 : out std_logic;\n');
        fprintf(fid,'        data_out2 : out std_logic;\n');
        fprintf(fid,'        index : out std_logic;\n');
        fprintf(fid,'        en_neuron : out std_logic;\n');
        fprintf(fid,'        next_data_pool : out std_logic;\n');
        fprintf(fid,'        next_pipeline_step : out std_logic);\n');
        fprintf(fid, 'end GEN%d; \n', layer);
        fprintf(fid, 'architecture Behavioral of GEN%d is\n', layer);
        fprintf(fid, 'type state_type is (idle , s_wait, s0, s1);\n');
        fprintf(fid, 'signal state_reg, state_next : state_type;\n');
        fprintf(fid, '--REGISTERS\n\n');
        fprintf(fid, 'signal index_reg, index_next : unsigned (log2c(pool%d_size) + 1  downto 0);\n', layer);
        fprintf(fid, 'signal count_reg, count_next: unsigned(log2c(input_sizeL%d)-1 + log2c(mult%d) + log2c(pool%d_size) + log2c(number_of_layers%d)  downto 0) :=  (others=>''0'');\n', layer, layer, layer + 1, layer);
        fprintf(fid, 'signal  next_data_pool_reg, next_data_pool_next, next_pipeline_step_reg, next_pipeline_step_next,data_reg, data_next, data2_reg, data2_next : std_logic;\n\n');
        fprintf(fid, '--CONSTANTS\n');
        fprintf(fid, 'signal data_max : unsigned(log2c(input_sizeL%d)-1 downto 0):=  (others=>''0'');\n\n', layer);
        fprintf(fid, 'begin\n\n');
        fprintf(fid, '--Register\n');
        fprintf(fid, 'process(clk)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '    if (clk''event and clk = ''1'') then\n');
        fprintf(fid, '        if (rst = ''0'') then\n');
        fprintf(fid, '            count_reg <= (others => ''0'');\n');
        fprintf(fid, '            index_reg <= (others => ''0'');\n');
        fprintf(fid, '            state_reg <= idle;\n');
        fprintf(fid, '            next_data_pool_reg <= ''0'';\n');
        fprintf(fid, '            data2_reg <= ''0'';\n');
        fprintf(fid, '            data_reg <= ''0'';\n');
        fprintf(fid, '        else\n');
        fprintf(fid, '            index_reg <= index_next;\n');
        fprintf(fid, '            state_reg <= state_next;\n');
        fprintf(fid, '            next_data_pool_reg <= next_data_pool_next;\n');
        fprintf(fid, '            next_pipeline_step_reg <= next_pipeline_step_next;\n');
        fprintf(fid, '            data_reg <= data_next;\n');
        fprintf(fid, '            data2_reg <= data2_next;\n');
        fprintf(fid, '            if (index_reg > pool%d_size - 1) then\n', layer);
        fprintf(fid, '                count_reg <= count_next;\n');
        fprintf(fid, '            end if;\n');
        fprintf(fid, '        end if;\n');
        fprintf(fid, '    end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, '--Next-state logic\n');
        fprintf(fid, 'process(rst_red, data_zero, data_max, state_reg, index_reg, data_in, count_reg, next_data_pool_reg, next_pipeline_step_reg, data2_reg, data_reg)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '    count_next <= count_reg;\n');
        fprintf(fid, '    index_next <= index_reg;\n');
        fprintf(fid, '    state_next <= state_reg;\n');
        fprintf(fid, '    next_data_pool_next <= next_data_pool_reg;\n');
        fprintf(fid, '    next_pipeline_step_next <= next_pipeline_step_reg;\n');
        fprintf(fid, '    data_next <= data_reg;\n');
        fprintf(fid, '    data2_next <= data2_reg;\n');
        fprintf(fid, '    en_neuron <= ''0'';\n');
        fprintf(fid, '    index <= ''0'';\n');
        fprintf(fid, 'case state_reg is\n');
        fprintf(fid, 'when idle  =>      --Reset state\n');
        fprintf(fid, '     next_data_pool_next <= ''0'';\n');
        fprintf(fid, '     next_pipeline_step_next <=''0'';\n');
        fprintf(fid, '     en_neuron <= ''0'';\n');
        fprintf(fid, '     index <= ''0'';\n');
        fprintf(fid, '     data_next <= ''0'';\n');
        fprintf(fid, '     count_next <= (others=>''0'');\n');
        fprintf(fid, '     index_next <= (others=>''0'');\n');
        fprintf(fid, '     state_next <= s_wait;\n');
        fprintf(fid, '     data2_next <= ''0'';\n');
        fprintf(fid, 'when s_wait =>\n');
        fprintf(fid, '     next_data_pool_next <= ''0'';\n');
        fprintf(fid, '     data2_next <= ''0'';\n');
        fprintf(fid, '     index <= ''0'';\n');
        fprintf(fid, '     data_next <= ''0'';\n');
        fprintf(fid, '     next_pipeline_step_next <= ''0'';\n');
        fprintf(fid, '     if(data_in = ''1'') then  --When new data is availale to be processed if it''s zero we don''t have to do the MAAC operation as the result will be direclty zero if is not zero we move to the processing state.\n');
        fprintf(fid, '        state_next <= s0;\n');
        fprintf(fid, '     end if; \n');
        fprintf(fid, '      if(data_zero = ''1'') then\n');
        fprintf(fid, '        state_next <= s1;\n');
        fprintf(fid, '     end if;\n');
        fprintf(fid, '     if(rst_red = ''1'') then\n');
        fprintf(fid, '        state_next <= idle;\n');
        fprintf(fid, '    end if;  \n');
        fprintf(fid,'\n');
        fprintf(fid, 'when s0 =>    --Generates control signals for processing a non-zero data\n\n');
        fprintf(fid,'\n');
        fprintf(fid, '--ReLU and Pool control signals\n\n');
        fprintf(fid, 'if(index_reg /= pool%d_size + 1) then   --index signal takes care of passing the data from the relu to the pool, counts up to the number of cycles equal to the size of the filter pool, and then sends a 1 in the nex_data_pool signal.\n', layer);
        fprintf(fid, '   index_next <= index_reg + 1;\n');
        fprintf(fid, '   if(index_reg < pool%d_size) then\n', layer);
        fprintf(fid, '      index <= ''1'';\n');
        fprintf(fid, '   else\n');
        fprintf(fid, '      en_neuron <= ''1'';\n');
        fprintf(fid, '   end if;\n');
        fprintf(fid, 'else \n');
        fprintf(fid, '   en_neuron <= ''1'';\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'if(index_reg = pool%d_size - 1 and next_data_pool_reg = ''0'' ) then   --notifies the maxPool module that the data has been processed\n', layer);
        fprintf(fid, '   next_data_pool_next <= ''1'';\n');
        fprintf(fid, 'end if;\n\n');
        fprintf(fid,'\n');
        fprintf(fid, '--Conv control signals\n\n');
        fprintf(fid, 'if(count_reg(log2c(input_sizeL%d)-1 downto 0) = data_max ) then    --One data is processed\n', layer);
        fprintf(fid, '   if( count_reg(log2c(number_of_layers%d) + log2c(input_sizeL%d)-1 downto log2c(input_sizeL%d)) = number_of_layers%d - 1 ) then --All the data available from the neurons in the last layers has been processed              \n', layer, layer, layer, layer);
        fprintf(fid, '    if(count_reg(log2c(mult%d)+ log2c(number_of_layers%d) + log2c(input_sizeL%d)-1 downto log2c(number_of_layers%d) + log2c(input_sizeL%d))= mult%d - 1) then    --One filter pass is processed    \n', layer, layer, layer, layer, layer, layer);
        fprintf(fid, '      if(count_reg(log2c(input_sizeL%d)-1 + log2c(mult%d) + log2c(number_of_layers%d) + log2c(pool%d_size) downto log2c(number_of_layers%d) + log2c(mult%d) + log2c(input_sizeL%d)) = pool%d_size - 1) then --One new data is available to be processed by the third layer\n', layer, layer, layer, layer + 1, layer, layer, layer, layer+1);
        fprintf(fid, '           data2_next <= ''1'';            --We notify the next layer that there is a new data available\n');
        fprintf(fid, '          count_next <= (others => ''0''); --add 1 if it is a power of 2, otherwise calculate the number needed to saturate the next bit.\n');
        fprintf(fid, '       else\n');
        a = strcat(num2str(dec2bin(mult - 1)), num2str(dec2bin(conv_z - 1)),  num2str(dec2bin((input_size - 1))));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '          count_next <= count_reg + %d;  --add 1 if it is a power of 2, otherwise calculate the number needed to saturate the next bit.\n', n);
        fprintf(fid, '          next_pipeline_step_next <= ''1''; --We notify the neurons that the data is processed and start a new filter pass\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, '     else\n');
        a = strcat(num2str(dec2bin(conv_z - 1)),  num2str(dec2bin((input_size - 1))));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '        count_next <= count_reg + %d;      --add 1 if it is a power of 2, otherwise calculate the number needed to saturate the next bit.\n', n);
        fprintf(fid, '     end if;\n');
        fprintf(fid, '     data_next <= ''1'';\n');
        fprintf(fid, '     state_next <= s_wait;\n');
        fprintf(fid, '   else\n');
        a = strcat( num2str(dec2bin((input_size - 1))));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '    count_next <= count_reg + %d;     \n', n);
        fprintf(fid, '   end if;\n');
        fprintf(fid, '   index_next <= (others=>''0'');\n');
        fprintf(fid, 'else\n');
        fprintf(fid, '    count_next <= count_reg + 1;\n');
        fprintf(fid, 'end if;');
        fprintf(fid, '\n');
        fprintf(fid, 'when s1 =>\n');
        fprintf(fid, '-- ReLU and Pool control signals\n');
        fprintf(fid, 'if (index_reg /= pool%d_size + 1) then\n', layer);
        fprintf(fid, '  index_next <= index_reg + 1;\n');
        fprintf(fid, '  if (index_reg < pool%d_size) then\n', layer);
        fprintf(fid, '    index <= ''1'';\n');
        fprintf(fid, '  end if;\n');
        fprintf(fid, 'else\n');
        fprintf(fid, '  en_neuron <= ''1'';\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'if (index_reg = pool%d_size - 1 and next_data_pool_reg = ''0'') then\n', layer);
        fprintf(fid, '  next_data_pool_next <= ''1'';\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, '\n');
        fprintf(fid, '-- Conv control signals\n');
        fprintf(fid, 'if (count_reg(log2c(number_of_layers%d) + log2c(input_sizeL%d)-1 downto log2c(input_sizeL%d)) = number_of_layers%d - 1) then\n', layer, layer, layer, layer);
        fprintf(fid, '  if (count_reg(log2c(mult%d)+ log2c(number_of_layers%d) + log2c(input_sizeL%d)-1 downto log2c(number_of_layers%d) + log2c(input_sizeL%d))= mult%d - 1) then\n', layer, layer, layer, layer, layer, layer);
        fprintf(fid, '    if (count_reg(log2c(input_sizeL%d)-1 + log2c(mult%d) + log2c(number_of_layers%d) + log2c(pool%d_size) downto log2c(number_of_layers%d) + log2c(mult%d) + log2c(input_sizeL%d)) = pool%d_size - 1) then\n', layer, layer, layer, layer + 1, layer, layer, layer, layer + 1);
        fprintf(fid, '      data2_next <= ''1'';\n');
        fprintf(fid, '      count_next <= (others => ''0'');\n');
        fprintf(fid, '    else\n');
        a = strcat(num2str(dec2bin(mult - 1)), num2str(dec2bin(conv_z - 1)),  num2str(dec2bin(0, log2(input_size))));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '      count_next <= count_reg + %d;\n', n);
        fprintf(fid, '      next_pipeline_step_next <= ''1'';\n');
        fprintf(fid, '    end if;\n');
        fprintf(fid, '  else\n');
        a = strcat(num2str(dec2bin(conv_z - 1)),  num2str(dec2bin(0, log2(input_size))));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '    data_next <= ''1'';\n');
        fprintf(fid, '    count_next <= count_reg + %d;\n', n);
        fprintf(fid, '  end if;\n');
        fprintf(fid, '  index_next <= (others => ''0'');\n');
        fprintf(fid, '  state_next <= s_wait;\n');
        fprintf(fid, 'else\n');
        a = strcat(num2str(dec2bin(0, log2(input_size))));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '  count_next <= count_reg + %d;\n', n);
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'end case;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, '--constants\n\n');
        fprintf(fid, 'data_max <= (others => ''1'');         --Max count value\n\n');
        fprintf(fid, '--output logic\n\n');
        fprintf(fid, 'count <= count_reg(log2c(input_sizeL%d)-1 downto 0);\n', layer);
        fprintf(fid, 'mul <= std_logic_vector(count_reg(log2c(mult%d)+ log2c(number_of_layers%d) + log2c(input_sizeL%d)-1 downto log2c(number_of_layers%d) + log2c(input_sizeL%d)));\n', layer, layer, layer, layer, layer);
        fprintf(fid, 'layer <= std_logic_vector(count_reg(log2c(number_of_layers%d)  + log2c(input_sizeL%d)-1  downto  log2c(input_sizeL%d)));\n', layer, layer, layer);
        fprintf(fid, 'next_pipeline_step <= next_pipeline_step_reg;\n');
        fprintf(fid, 'next_data_pool <= next_data_pool_reg;\n');
        fprintf(fid, 'data_out1 <= data_reg when data2_reg = ''0'' else ''0'';\n');
        fprintf(fid, 'data_out2<= data2_reg;\n');
        fprintf(fid, 'end Behavioral;\n');
        fclose(fid);
end


% This function generates the module for the control signal generator of
% the last layer of the CNN part of the network
% INPUTS
% Number of layer of the generator
% Number of layers of the convolutional filters (z dimension)
function [] = ControlLastLayer(layers, conv_z)
 name = sprintf('CNN_Network/CNN/GEN%d.vhd', layers);
        fid = fopen(name, 'wt');
        fprintf(fid,'------------------------------GENERATOR LAYER %d ----------------------------\n', layers);
        fprintf(fid,'--This module is in charge of producing all the control signals of its layer, which allow to synchronize the operation of all the modules.\n');
        fprintf(fid,'--INPUTS\n');
        fprintf(fid,'--data_in_cnn : indicates that there is a data to be processed from the cnn last layer.\n');
        fprintf(fid,'--data_in_fc : indicates that a data has been processed by the FC network.\n');
        fprintf(fid,'--OUTPUTS\n');
        fprintf(fid,'--data_new : indicates that the cnn can process a new data\n');
        fprintf(fid,'--layer : indicates the layer of the matrix resulting from the previous stage that we are processing at this moment.\n');
        fprintf(fid,'--index: signal that is passed to the relu module to transmit the stored data.\n');
        fprintf(fid,'--next_dato_pool: indicates that there is new data from process to the pool module. \n');
        fprintf(fid, '--index: seÃ±al que se le pasa al modulo relu para que transmita los datos almacenados\n');
        fprintf(fid, 'library IEEE;\n');
        fprintf(fid, 'use IEEE.STD_LOGIC_1164.ALL;\n');
        fprintf(fid, 'use work.tfg_irene_package.ALL;\n');
        fprintf(fid, 'use IEEE.NUMERIC_STD.ALL;\n');
        fprintf(fid, 'entity GEN%d is\n', layers);
        fprintf(fid, '\t Port ( clk : in std_logic;\n');
        fprintf(fid,'           rst : in std_logic;\n');
        fprintf(fid,'           rst_red : in std_logic;\n');
        fprintf(fid,'           data_in_fc : in std_logic;\n');
        fprintf(fid,'           data_in_cnn : in std_logic;\n');
        fprintf(fid,'           data_new : out std_logic;\n');
        fprintf(fid,'           layer : out std_logic_vector(log2c(number_of_layers%d) - 1 downto 0);\n', layers);
        fprintf(fid,'           index : out std_logic;\n');
        fprintf(fid,'           next_data_pool : out std_logic);\n');
        fprintf(fid, 'end GEN%d; \n', layers);
        fprintf(fid, 'architecture Behavioral of GEN%d is\n', layers);
        fprintf(fid,'type state_type is (idle , s_wait, s0, s1);\n');
        fprintf(fid,'signal state_reg, state_next : state_type;\n');
        fprintf(fid,'--REGISTERS\n');
        fprintf(fid,'signal index_reg, index_next : unsigned (log2c(pool%d_size) + 1  downto 0);\n', layers);
        fprintf(fid,'signal count_reg, count_next : unsigned(log2c(result_size) + log2c(number_of_layers%d) - 1 downto 0) := (others=> ''0'');\n', layers);
        fprintf(fid,'signal next_data_pool_reg, next_data_pool_next, first_reg, first_next: std_logic := ''0'';\n');
        fprintf(fid,'-- Register \n');
        fprintf(fid,'begin\n');
        fprintf(fid,'process(clk) \n');
        fprintf(fid,'begin \n');
        fprintf(fid,'if (clk''event and clk = ''1'') then \n');
        fprintf(fid,'     if (rst = ''0'') then \n');
        fprintf(fid,'      index_reg <= (others=>''0'');\n');
        fprintf(fid,'      state_reg <= idle;\n');
        fprintf(fid,'      next_data_pool_reg <= ''0'';\n');
        fprintf(fid,'      count_reg <= (others =>''0'');\n');
        fprintf(fid,'     else \n');
        fprintf(fid,'      index_reg <= index_next;\n');
        fprintf(fid,'      state_reg <= state_next;\n');
        fprintf(fid,'      next_data_pool_reg <= next_data_pool_next;\n');
        fprintf(fid,'      count_reg <= count_next;\n');
        fprintf(fid,'      first_reg <= first_next;\n');
        fprintf(fid,'    end if; \n');
        fprintf(fid,'end if; \n');
        fprintf(fid,'end process; \n');
        fprintf(fid,'--Next-state logic \n');
        fprintf(fid, 'process( rst_red, state_reg, index_reg, data_in_fc, data_in_cnn, count_reg, next_data_pool_reg, first_reg)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '    first_next <= first_reg;\n');
        fprintf(fid, '    count_next <= count_reg;\n');
        fprintf(fid, '    index_next <= index_reg;\n');
        fprintf(fid, '    state_next <= state_reg;\n');
        fprintf(fid, '    next_data_pool_next <= next_data_pool_reg;\n');
        fprintf(fid, '    data_new <= ''0'';\n');
        fprintf(fid, '    index <= ''0'';\n');
        fprintf(fid, 'case state_reg is\n');
        fprintf(fid, 'when idle  =>\n');
        fprintf(fid, '    next_data_pool_next <= ''0'';\n');
        fprintf(fid, '    index <= ''0'';\n');
        fprintf(fid, '    count_next <= (others=>''0'');\n');
        fprintf(fid, '    index_next <= (others=>''0'');\n');
        fprintf(fid, '    state_next <= s_wait;\n');
        fprintf(fid, '    first_next <= ''1'';\n');
        fprintf(fid, 'when s_wait =>\n');
        fprintf(fid, '     next_data_pool_next <= ''0'';\n');
        fprintf(fid, '     index <= ''0'';\n');
        fprintf(fid, '     if(data_in_fc = ''1'' or data_in_cnn = ''1'') then\n');
        fprintf(fid, '        index_next <= (others=>''0'');\n');
        fprintf(fid, '        state_next <= s0;\n');
        fprintf(fid, '        if(data_in_cnn = ''1'' and  count_reg(log2c(result_size) + log2c(number_of_layers%d) - 1 downto log2c(number_of_layers%d) ) /= result_size -2 ) then\n', layers, layers);
        fprintf(fid, '            data_new <= ''1'';\n');
        fprintf(fid, '        end if;\n');
        fprintf(fid, '     end if;\n');
        fprintf(fid, '     if(rst_red = ''1'') then\n');
        fprintf(fid, '        state_next <= idle;\n');
        fprintf(fid, '     end if;\n');
        fprintf(fid, 'when s0 =>\n');
        fprintf(fid, 'if(count_reg(log2c(number_of_layers%d) - 1 downto 0) = number_of_layers%d - 1) then\n', layers, layers);
        a = strcat(num2str(dec2bin(conv_z - 1)));
        n = ((2^(length(a)) - bin2dec(a)));
        fprintf(fid, '      count_next <= count_reg + %d;\n', n);
        fprintf(fid, '   else\n');
        fprintf(fid, '     if(first_reg = ''0'') then\n');
        fprintf(fid, '         count_next <= count_reg + 1;\n');
        fprintf(fid, '     else\n');
        fprintf(fid, '         first_next <= ''0'';\n');
        fprintf(fid, '     end if;\n');
        fprintf(fid, '  end if;\n');
        fprintf(fid, '  state_next <= s1;\n');
        fprintf(fid, 'when s1 =>\n');
        fprintf(fid, '\n');
        fprintf(fid, '--Control signals for Relu and MaxPool\n\n');
        fprintf(fid, 'if(index_reg /= pool%d_size  ) then   --index signal takes care of passing the data from the relu to the pool, counts up to the number of cycles equal to the size of the filter pool, and then sends a 1 in the nex_data_pool signal.\n', layers);
        fprintf(fid, '   index_next <= index_reg + 1;\n');
        fprintf(fid, '   if(index_reg < pool%d_size) then\n', layers);
        fprintf(fid, '      index <= ''1'';\n');
        fprintf(fid, '   else\n');
        fprintf(fid, '      index <= ''0'';\n');
        fprintf(fid, '   end if;\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'if(index_reg = pool%d_size - 1 and next_data_pool_reg = ''0'' ) then   --signal notifying the MAXPOOL module that the data is being processed\n', layers);
        fprintf(fid, '     next_data_pool_next <= ''1'';\n');
        fprintf(fid, '     state_next <= s_wait;\n');
        fprintf(fid, 'end if;\n\n');
        fprintf(fid, 'end case;\nend process;\n\n');
        fprintf(fid, '--Output logic\n');
        fprintf(fid, 'layer <= std_logic_vector(count_reg(log2c(number_of_layers%d) - 1 downto 0));\n', layers);
        fprintf(fid, 'next_data_pool <= next_data_pool_reg;\n');
        fprintf(fid, 'end Behavioral;\n');
        fclose(fid);
           
end

